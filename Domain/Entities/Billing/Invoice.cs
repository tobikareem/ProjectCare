using CarePath.Domain.Entities.Common;
using CarePath.Domain.Entities.Identity;
using CarePath.Domain.Enumerations;

namespace CarePath.Domain.Entities.Billing;

/// <summary>
/// Invoice issued to a client, aggregating one or more care shifts into line items and
/// tracking payments through to full settlement.
/// </summary>
/// <remarks>
/// <para>
/// <b>Status lifecycle:</b>
/// <see cref="InvoiceStatus.Draft"/> → <see cref="InvoiceStatus.Sent"/> →
/// <see cref="InvoiceStatus.PartiallyPaid"/> or <see cref="InvoiceStatus.Paid"/> (terminal);
/// or <see cref="InvoiceStatus.Overdue"/> if past due; or <see cref="InvoiceStatus.Cancelled"/> if voided.
/// Call <see cref="RecalculateStatus"/> after recording any payment to keep <see cref="Status"/> current.
/// </para>
/// <para>
/// <b>Invoice number format:</b> INV-YYYYMMDD-XXXX (e.g., INV-20260216-0001).
/// Generation is handled by the Application layer (requires a database sequence or counter).
/// </para>
/// <para>
/// <b>Computed totals:</b> <see cref="Subtotal"/>, <see cref="Total"/>, <see cref="AmountPaid"/>,
/// and <see cref="Balance"/> are derived from the <see cref="LineItems"/> and <see cref="Payments"/>
/// collections. Requires both collections to be loaded (EF Core: use
/// <c>.Include(i =&gt; i.LineItems).Include(i =&gt; i.Payments)</c>);
/// returns 0 silently if a collection is empty due to lazy/deferred loading.
/// </para>
/// </remarks>
public class Invoice : BaseEntity
{
    /// <summary>
    /// Human-readable invoice number (format: INV-YYYYMMDD-XXXX).
    /// Generated by the Application layer on invoice creation.
    /// </summary>
    public string InvoiceNumber { get; set; } = string.Empty;

    // Foreign Keys and Navigation

    /// <summary>Foreign key to the client being invoiced.</summary>
    public Guid ClientId { get; set; }

    /// <summary>Navigation to the <see cref="Client"/> being invoiced. Required.</summary>
    public Client Client { get; set; } = null!;

    // Dates

    /// <summary>
    /// UTC date the invoice was issued. Set by the Application layer to the billing period end date —
    /// do not use object construction time. Default: <see cref="DateTime.MinValue"/> (unset).
    /// </summary>
    public DateTime InvoiceDate { get; set; }

    /// <summary>UTC date by which payment is due. Used to determine <see cref="InvoiceStatus.Overdue"/> status.</summary>
    public DateTime DueDate { get; set; }

    /// <summary>UTC date the invoice was fully paid. <c>null</c> until <see cref="IsFullyPaid"/> becomes <c>true</c>.</summary>
    public DateTime? PaidDate { get; set; }

    /// <summary>Current lifecycle status of the invoice. Call <see cref="RecalculateStatus"/> after payments.</summary>
    public InvoiceStatus Status { get; set; } = InvoiceStatus.Draft;

    /// <summary>Tax amount in USD applied to the invoice. Added on top of <see cref="Subtotal"/> to produce <see cref="Total"/>.</summary>
    public decimal TaxAmount { get; set; }

    /// <summary>Optional notes visible on the invoice (e.g., payment terms, late-fee policy).</summary>
    public string? Notes { get; set; }

    // Navigation Collections

    /// <summary>Line items (typically one per shift) that make up this invoice.</summary>
    public ICollection<InvoiceLineItem> LineItems { get; set; } = new List<InvoiceLineItem>();

    /// <summary>All payment transactions recorded against this invoice.</summary>
    public ICollection<Payment> Payments { get; set; } = new List<Payment>();

    // Computed Properties

    /// <summary>
    /// Sum of all line-item totals (before tax).
    /// Requires <see cref="LineItems"/> to be loaded; returns 0 if the collection is empty.
    /// </summary>
    public decimal Subtotal => LineItems.Sum(li => li.Total);

    /// <summary>Total amount due: <see cref="Subtotal"/> + <see cref="TaxAmount"/>.</summary>
    public decimal Total => Subtotal + TaxAmount;

    /// <summary>
    /// Total amount received from settled payments only.
    /// Pending, failed, and refunded payments are excluded.
    /// Requires <see cref="Payments"/> to be loaded; returns 0 if the collection is empty.
    /// </summary>
    public decimal AmountPaid => Payments
        .Where(p => p.Status == PaymentStatus.Settled)
        .Sum(p => p.Amount);

    /// <summary>Outstanding balance: <see cref="Total"/> − <see cref="AmountPaid"/>.</summary>
    public decimal Balance => Total - AmountPaid;

    /// <summary><c>true</c> when <see cref="Balance"/> is zero or negative (overpayment).</summary>
    public bool IsFullyPaid => Balance <= 0;

    // Domain Methods

    /// <summary>
    /// Recalculates and updates <see cref="Status"/> based on the current payment balance.
    /// Call this method after recording any payment against this invoice.
    /// </summary>
    /// <remarks>
    /// Transition rules:
    /// <list type="bullet">
    ///   <item><see cref="Balance"/> ≤ 0 → <see cref="InvoiceStatus.Paid"/>.</item>
    ///   <item><see cref="AmountPaid"/> &gt; 0 but <see cref="Balance"/> &gt; 0 → <see cref="InvoiceStatus.PartiallyPaid"/>.</item>
    /// </list>
    /// No-op when <see cref="Status"/> is <see cref="InvoiceStatus.Cancelled"/>.
    /// </remarks>
    public void RecalculateStatus()
    {
        if (Status == InvoiceStatus.Cancelled)
            return;

        if (Balance <= 0)
            Status = InvoiceStatus.Paid;
        else if (AmountPaid > 0)
            Status = InvoiceStatus.PartiallyPaid;
    }
}
